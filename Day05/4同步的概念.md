# 同步的概念

***说明:***

​	***同步就是协同步调,,按预定的先后次序进行运行***

### 1.解决线程同时修改全局变量的方式

计算错误问题,可以通过线程同步来进行解决(互斥锁)



# 互斥锁



***当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制***

***线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。***

***互斥锁为资源引入一个状态：锁定/非锁定***

***某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。***

### threading模块中定义了Lock类

```
# 创建锁子
mutex = threading.lock()
# 锁定
mutex.acquire()
# 释放
mutex.release()

```

#### 注意：

- 如果这个锁之前是没有上锁的，那么acquire不会堵塞

- 如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止

  

#### 使用互斥锁完成2个线程对同一个全局变量各加100万次的操作

```

import threading,time

num1 = 0


def test1(num):
    global num1
    for i in range(num):
        mutex.acquire()
        num1 +=1
        mutex.release()

    print("---test2---num1=%d"%num1)

def test2(num):
    global num1
    for i in range(num):
        mutex.acquire()
        num1 += 1
        mutex.release()

    print("---test2---num1=%d" % num1)

mutex = threading.Lock()

# 创建2个线程，让他们各自对g_num加1000000次
p1 = threading.Thread(target=test1, args=(1000000,))
p1.start()

p2 = threading.Thread(target=test2, args=(1000000,))
p2.start()
```



#### 上锁＆解锁的过程

***当一个程序调用锁`acquuire()`方法获得锁时,锁就进入"lock"状态.***

***每次只有一个线程会获得锁.此时另一个线程试图获得这个锁时,该线程就会变成`blocked`状态***

***,简称"阻塞",知道拥有所的线程调用所得`release()`方法后,所就会进入`unlocked`状态***

***线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁,并使其进入`running`状态.***



### 总结

- 锁的好处:
  - 确保了某段关键代码只能由一个线程从头到尾完整的执行

- 锁的坏处
  - 组织多线程并发执行,包含锁的代码实际只能以单线程模式执行,降低效率
  - 由于可以存在多个锁,不同线程有不同的锁,并试图获取对方持有的锁时,可能会造成死锁